# Memo

后面再整理

## return 和 yield

- return后面的程序不再执行
- yield创建了一个迭代器，def定义的生成器返回一个对象；
- def定义的函数里面有def,就自动变成生成器，支持next和send函数；
- 多次调用next，会从上次yield后面的代码继续执行；
- send可以为yield表达式传参
- yield里面一般用while true，因为一直next到最后没有值的话会报错；
- yield一般与for一起用


## python 深拷贝与浅拷贝

- 对于不可变对象：数字和字符串，赋值/浅拷贝/深拷贝都没有区别，它们的对象引用永远指向同一个内存空间；
- 浅拷贝，对一个对象进行拷贝，只拷贝外围的对象本身，内部的元素只是拷贝了一个引用， 只是新创建了一个类型跟愿对象一样，内容是愿对象的引用。浅拷贝的对象是新的，第一项的引用内容是久的。
- 浅拷贝的几种实现方式：切片[:]，工厂函数如list（），dict（），使用copy（）；
- 深拷贝：外围和内部元素都进行了拷贝对象本身，而非引用。把对象复制一遍，对象中的引用的其他对象也复制了；

## python list 和 tuple（元组）

- list和tuple里面都可以存不同类型的值；都可以通过索引访问；
- list可变，用[]创建，有append，insert，pop等方法；
- tuple不可变，用（）创建；创建了就不能修改，但如果tuple里面有list对象，这个list还是可以变的，如 a=(1, 2, [3,3,3]);
- tuple只用一个元素的话，要加个 ， ，用来区分（）这个操作符；

## top K

- 可以用大根堆，每次pop最大的值，pop K 次；
- 利用快排思想，选一个数做基准，小的放到左边，大的放到右边，这时判断左右数组的长度，如果左边的大于K，说明K大值在左边，否则在右边；    
  如果在左边，再对左边进行如上操作，直到找到左边长度为K-1，那么那个标准值就是第K大的数；

